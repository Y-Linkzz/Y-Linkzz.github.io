# 应用规模化

## [单文件组件 (Single-File Components), 简称 SFC](https://cn.vuejs.org/guide/scaling-up/sfc.html)

## 如何看待关注点分离?
前端开发的关注点不是完全基于文件类型分离的。前端工程化的最终目的都是为了能够更好地维护代码。关注点分离不应该是教条式地将其视为文件类型的区别和分离，仅仅这样并不够帮我们在日益复杂的前端应用的背景下提高开发效率

## [测试](https://cn.vuejs.org/guide/scaling-up/tooling.html#testing)
-   Cypress 推荐用于 E2E 测试。也可以通过 Cypress 组件测试运行器来给 Vue SFC 作单文件组件测试。
-   Vitest 是一个追求更快运行速度的测试运行器，由 Vue / Vite 团队成员开发。主要针对基于 Vite 的应用设计，可以为组件提供即时响应的测试反馈
-   Jest 可以通过 vite-jest 配合 Vite 使用。不过只推荐在你已经有一套基于 Jest 的测试集、且想要迁移到基于 Vite 的开发配置时使用，因为 Vitest 也能够提供类似的功能，且后者与 Vite 的集成更方便高效

## [代码规范](https://cn.vuejs.org/guide/scaling-up/tooling.html#linting)

## 测试
### 单元测试
编写单元测试是为了验证小的、独立的代码单元是否按预期工作。一个单元测试通常覆盖一个单个函数、类、组合式函数或模块。单元测试侧重于逻辑上的正确性，只关注应用整体功能的一小部分。他们可能会模拟你的应用环境的很大一部分（如初始状态、复杂的类、第三方模块和网络请求）
#### Vue 的特定功能进行单元测试 （Vitest）
- 组合式函数
- 组件

#### 组件挂载库
组件测试通常涉及到单独挂载被测试的组件，触发模拟的用户输入事件，并对渲染的 DOM 输出进行断言。有一些专门的工具库可以使这些任务变得更简单
-   @testing-library/vue 是一个 Vue 的测试库，专注于测试组件而不依赖其他实现细节。因其良好的设计使得代码重构也变得非常容易。它的指导原则是，测试代码越接近软件的使用方式，它们就越值得信赖
-   @vue/test-utils 是官方的底层组件测试库，用来提供给用户访问 Vue 特有的 API。@testing-library/vue 也是基于此库构建的

推荐使用 @testing-library/vue 测试应用中的组件, 因为它更匹配整个应用的测试优先级。只有在你构建高级组件、并需要测试内部的 Vue 特有 API 时再使用 @vue/test-utils

## [服务端渲染 (SSR)](https://cn.vuejs.org/guide/scaling-up/ssr.html)
Vue.js 是一个用于构建客户端应用的框架。默认情况下，Vue 组件的职责是在浏览器中生成和操作 DOM。然而，Vue 也支持将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用。

一个由服务端渲染的 Vue.js 应用也可以被认为是“同构的”(Isomorphic) 或“通用的”(Universal)，因为应用的大部分代码同时运行在服务端和客户端。

### SSR 时还有一些权衡之处需要考量
-   **开发中的限制**。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行
-   **更多的与构建配置和部署相关的要求**。服务端渲染的应用需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上
-   **更高的服务端负载**。在 Node.js 中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU 资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略

在为你的应用使用 SSR 之前，你首先应该问自己是否真的需要它。这主要取决于首屏加载速度对应用的重要程度。例如，如果你正在开发一个**内部的管理面板，初始加载时的那额外几百毫秒对你来说并不重要，这种情况下使用 SSR 就没有太多必要了**。然而，**在内容展示速度极其重要的场景下，SSR 可以尽可能地帮你实现最优的初始加载性能**

## SSG 静态站点生成 (Static-Site Generation，缩写为 SSG)，也被称为预渲染
如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管

### SSR vs. SSG
SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是静态：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署

如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 /、/about 和 /contact 等)，那么你可能需要 SSG 而不是 SSR。SSG 也非常适合构建基于内容的网站，比如文档站点或者博客

## SSR的流程
-   服务端直接渲染成 HTML 字符串，返回给客户端。这时HTML 在客户端是完全静态的
-   客户端中：Vue 会创建一个与服务端完全相同的应用实例，然后将每个组件与它应该控制的 DOM 节点相匹配，并添加 DOM 事件监听器
```js
    // 该文件运行在浏览器中
    import { createSSRApp } from 'vue'

    const app = createSSRApp({
    // ...和服务端完全一致的应用实例
    })

    // 在客户端挂载一个 SSR 应用时会假定
    // HTML 是预渲染的，然后执行激活过程，
    // 而不是挂载新的 DOM 节点
    app.mount('#app')
```

## SSR 框架
-   [Nuxt](https://nuxt.com/)是一个构建于 Vue 生态系统之上的全栈框架，它为编写 Vue SSR 应用提供了丝滑的开发体验。更棒的是，你还可以把它当作一个静态站点生成器来用！我们强烈建议你试一试
-   [Quasar](https://quasar.dev/)是一个基于 Vue 的完整解决方案，它可以让你用同一套代码库构建不同目标的应用，如 SPA、SSR、PWA、移动端应用、桌面端应用以及浏览器插件。除此之外，它还提供了一整套 Material Design 风格的组件库
-   Vite SSR： 
Vite 提供了内置的 Vue 服务端渲染支持，但它在设计上是偏底层的。如果你想要直接使用 Vite，可以看看 vite-plugin-ssr，一个帮你抽象掉许多复杂细节的社区插件。
你也可以在这里查看一个使用手动配置的 Vue + Vite SSR 的示例项目，以它作为基础来构建。请注意，这种方式只有在你有丰富的 SSR 和构建工具经验，并希望对应用的架构做深入的定制时才推荐使用

## SSR 在组件生命周期钩子里的使用
因为没有任何动态更新，所以像 onMounted 或者 onUpdated 这样的生命周期钩子不会在 SSR 期间被调用，而只会在客户端运行。

你应该避免在 `setup()` 或者 `<script setup>` 的根作用域中使用会产生副作用且需要被清理的代码。这类副作用的常见例子是使用 setInterval 设置定时器。我们可能会在客户端特有的代码中设置定时器，然后在 onBeforeUnmount 或 onUnmounted 中清除。然而，由于 unmount 钩子不会在 SSR 期间被调用，所以定时器会永远存在。为了避免这种情况，请将含有**副作用的代码放到 onMounted 中**

## 激活不匹配 (SSR的HTML结构与客户端HTML不匹配)
1. 组件模板中存在不符合规范的 HTML 结构，渲染后的 HTML 被浏览器原生的 HTML 解析行为纠正导致不匹配。举例来说，一个常见的错误是 `<div>` 不能被放在 `<p>` 中

```html
    <!-- SSR -->
    <p><div>hi</div></p>

    <!-- 客户端 -->
    <p></p>
        <div>hi</div>
    <p></p>
```
https://www.w3docs.com/learn-html/html-p-tag.html
- `<p>标签成对出现。内容写在开始 (<p>) 和结束 (</p>) 标记之间。如果省略结束标记，则认为段落的结尾与下一个块级元素的开头匹配`
- `<div>是一个块元素，它的开始标签会导致父元素<p>关闭,因此<div>永远不能嵌套在里面<p>`
CSS 值是在 dom 解析之后应用的,即使我们让它div as inline in CSS没有用
- `元素的结束标记<div>是必需的,<div>元素的结尾将仅由其结束标记确定</div>，因此<p>内部元素不会破坏它`

2.  渲染所用的数据中包含随机生成的值。**由于同一个应用会在服务端和客户端执行两次，每次执行生成的随机数都不能保证相同**。避免随机数不匹配有两种选择
    1.  利用 v-if + onMounted 让需要用到随机数的模板只在客户端渲染。你所用的上层框架可能也会提供简化这个用例的内置 API，比如 VitePress 的 `<ClientOnly>` 组件
    2.  使用一个能够接受随机种子的随机数生成库，并确保服务端和客户端使用同样的随机数种子 (比如把种子包含在序列化的状态中，然后在客户端取回)。
3. 服务端和客户端的时区不一致。有时候我们可能会想要把一个时间转换为用户的当地时间，但在服务端的时区跟用户的时区可能并不一致，我们也并不能可靠的在服务端预先知道用户的时区。这种情况下，**当地时间的转换也应该作为纯客户端逻辑去执行**。

当 Vue 遇到激活不匹配时，它将尝试自动恢复并调整预渲染的 DOM 以匹配客户端的状态。这将导致一些渲染性能的损失，因为需要丢弃不匹配的节点并渲染新的节点，但大多数情况下，应用应该会如预期一样继续工作。尽管如此，最好还是在开发过程中发现并避免激活不匹配。






